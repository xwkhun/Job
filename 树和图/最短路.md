# 最短路

## 术语

源点是起点，汇点是终点。
单源最短路：从一个点到所有其他点的最短距离，如从1号点到n号点的最短路。（输入只有节点数n）
多源汇最短路：任选两个点，从一个点到另一个点的最短距离。（输入是节点数n和边数m）

## 分类

![最短路分类](/树和图/images/2023-04-13-11-24-13.png)

其中，朴素Dijkstra算法适用于稠密图，堆优化版Dijkstra算法适用于稀疏图
稀疏图和稠密图的区分是 n（节点数）和 m（边数）之间的关系，如果m是n^2级别的话，则是稠密图，m是n级别的话则是稀疏图。
稠密图用邻接矩阵来存储，稀疏图用邻接表来存储。

### 常见的最短路算法

1、Dijkstra算法

* 算法思想：


https://zhuanlan.zhihu.com/p/338414118

![](/树和图/images/2023-04-13-19-47-52.png)
![](/树和图/images/2023-04-13-19-48-07.png)

2、Bellman-Fold算法

* 算法思想：

![](/树和图/images/2023-04-14-14-48-03.png)

注：如果图中存在负权回路，那么不一定存在最短路径，如果负权回路不在1号点到n号点的路径上，则有最短路径，或者限制了经过k条边，则也有最短路径。
![](/树和图/images/2023-04-14-10-43-03.png)
![](/树和图/images/2023-04-14-10-46-55.png)
![](/树和图/images/2023-04-14-10-55-50.png)
![](/树和图/images/2023-04-14-11-33-02.png)


3、SPFA算法

* 算法思想：由上面Bellman-Fold算法优化而来，Bellman-Fold算法每次迭代遍历所有边来更新所有节点，但不是真的所有节点都会更新，也就是不一定dist[b]每次都变小，因为dist[a]不一定更新。SPFA就是从这一点进行优化，把变小了的节点存储到一个队列里，然后用它来更新一下与它相连的所有节点（后继）的距离。通俗地说，就是我更新过谁，就拿它来更新其他人。

* 在算法的代码实现上和dijkstra算法很像。

* spfa可以用来判断路径上是否有负环，原理如下：
在更新dist数组的同时维护一个cnt数组，cnt[x]表示从1号点到x号点所经过的边，当更新后的cnt[x] > n，说明路径上至少有 n + 1 个点，超过了 n 个点，那么至少有两个点是相同的（抽屉原理？），这个点的边权肯定是负的才能使更新后的点距离变小，因此存在负环。

![](/树和图/images/2023-04-14-15-08-03.png)
![](/树和图/images/2023-04-14-15-16-50.png)
![](/树和图/images/2023-04-14-15-17-02.png)

![](/树和图/images/2023-04-14-16-21-02.png)
![](/树和图/images/2023-04-14-16-21-59.png)

4、Floyd算法

![](/树和图/images/2023-04-14-16-56-49.png)
![](/树和图/images/2023-04-14-17-48-16.png)